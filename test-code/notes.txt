0mbr boot.bin search and load development:

1. 

sda1.bin's inode table starts at 323*4096
Since first inode is 11 and stat /sda/boot.bin output shows inode 12, inode of /sda/boot.bin
is at 00143100 + inode No. * inode size. 
No. of blocks in there also match that of stat's output: 8 blocks.

hexdump -C sda1.bin -n 4096 -s $((323*4096 + 12 * 256)) = 1323008 = 0x143000 
where 323 is start of inode table.
4096 is block size
12 is inode number used by boot.bin
256 inode size

root@ubuntu-desktop:/git.co/minix-dev-linux/test-code# hexdump -C sda1.bin -n 4096 -s $((323*4096+11*256))
00143b00  a4 81 00 00 21 00 00 00  72 2e e4 5f 92 19 e4 5f  |....!...r.._..._|
00143b10  92 19 e4 5f 00 00 00 00  00 00 01 00 08 00 00 00  |..._............|
00143b20  00 00 00 00 01 00 00 00  05 04 00 00 00 00 00 00  |................|
00143b30  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*

From here the block No. is 0x0405 therefore
oot@ubuntu-desktop:/git.co/minix-dev-linux/test-code# hexdump -C sda1.bin -n 512 -s $((0x405*4096))
00405000  0a 38 38 37 37 36 36 35  35 34 34 33 33 32 32 31  |.887766554433221|
00405010  31 38 38 37 37 36 36 35  35 34 34 33 33 32 32 31  |1887766554433221|
00405020  31 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |1...............|
00405030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|

maxofthree analysis:

maxofthree analysis
(https://cs.lmu.edu/~ray/notes/nasmtutorial/ section: Mixing C and Assembly Language)

a.out: 
1. program entry 0x4f0 and...from there is call main at 5f0
00000000000004f0 <_start>:
...
 50d:   48 8d 3d e6 00 00 00    lea    0xe6(%rip),%rdi        # 5fa <main>
 514:   ff 15 c6 0a 20 00       callq  *0x200ac6(%rip)        # 200fe0 <__libc_start_main@GLIBC_2.2.5>
...

2. main code appears to start at 5fa:
00000000000005fa <main>:
 5fa:   55                      push   %rbp
 5fb:   48 89 e5                mov    %rsp,%rbp
 5fe:   48 c7 c2 f9 ff ff ff    mov    $0xfffffffffffffff9,%rdx
 605:   48 c7 c6 fc ff ff ff    mov    $0xfffffffffffffffc,%rsi
...

3. we can determine 4f0 program entry from elf header using readelf -l utility, but 
we need to get 5f0 and jump directly from 7c00 by placing 5f0 offset at 800:0.


root@ixt-rack-39:/git.co/minix-dev-linux/test-code# objdump -D maxofthree.o

maxofthree.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <maxofthree>:
   0:   48 89 f8                mov    %rdi,%rax
   3:   48 39 f0                cmp    %rsi,%rax
   6:   48 0f 4c c6             cmovl  %rsi,%rax
   a:   48 39 d0                cmp    %rdx,%rax
   d:   48 0f 4c c2             cmovl  %rdx,%rax
  11:   c3                      retq


root@ixt-rack-39:/git.co/minix-dev-linux/test-code# hexdump -C a1.out | grep "48 89 f8"

00000130  48 89 f8 48 39 f0 48 0f  4c c6 48 39 d0 48 0f 4c  |H..H9.H.L.H9.H.L|

12.27.2020:
development branched into two separate branch now:
dev-1: will pursue boot.bin code where execution starts from assembler start label. In this branch, the code from <start>
executes OK, but function call to C goes to wrong offset possibly due to the fact non-elf relocation is not happening OK. 
Note that, boot.bin is created by stripping all elf-specific before <main> label therefore it could be expected.

dev-1-c-main: will pursue boot.bin code where execution starts from C and call asembler function. I can see 800:0 location
is correctly updated with the main() code however it appears vbox VM is trying to execute the 64-bit binary and interprating 
it wrongly when looking at u (disassembler) command from vboxdbg.
 
